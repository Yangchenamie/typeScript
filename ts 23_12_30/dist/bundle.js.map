{"version":3,"file":"bundle.js","sources":["../src/index.ts"],"sourcesContent":["\r\n\r\n// 联合类型(并集) | 按位或    交叉类型(交集)  & 按位与\r\n\r\ninterface Person1 {\r\n    handsome: string,\r\n    gender: boolean,\r\n    meta: {\r\n        n: string\r\n    }\r\n}\r\ninterface Person2 {\r\n    hight: string,\r\n    gender: boolean,\r\n    meta: {\r\n        n: string\r\n    }\r\n}\r\n/* 有其一就可以 */\r\ntype Person3 = Person1 | Person2;\r\n/* 都要有 */\r\ntype Person4 = Person1 & Person2;\r\n\r\n/* let person1:Person3 = {\r\n    hight:'高',\r\n    gender:true\r\n} */\r\n\r\nlet person4:Person4 = {\r\n    handsome:\"帅\",\r\n    hight:'高',\r\n    gender:false,\r\n    meta: {\r\n        n: 'q'\r\n    }\r\n}\r\n\r\n// type IGender = Person4['gender'];   \r\ntype IGender = Person4['meta']['n']  //如果两个类型不同没有交集 &后的结果是never\r\n\r\n\r\n/* 子类型可以赋予给父类型 (子类型的结构要包含父类型) */\r\nlet person5 :Person1 = person4;\r\nlet person6 :Person2 = person4;\r\n\r\n// 快速扩展属性\r\nlet obj = { name: 'zs', age: 18 }\r\nlet person: { name: string, age: number, address: string } = obj as typeof obj & { address: string }\r\n\r\n\r\nfunction merge<T extends object, K extends object>(obj1: T, obj2: K) {\r\n    return {...obj1, ...obj2}\r\n}\r\nlet result = merge(obj, { age: 20, address: \"china\" })\r\nconsole.log(result.age);\r\n\r\n\r\nexport { }"],"names":[],"mappings":";;;IAEA;IAqBA;;;IAGI;IAmBJ;IACA,IAAI,GAAG,GAAG,EAAE,IAAI,EAAE,IAAI,EAAE,GAAG,EAAE,EAAE,EAAE,CAAA;IAIjC,SAAS,KAAK,CAAqC,IAAO,EAAE,IAAO,EAAA;IAC/D,IAAA,OAAO,EAAC,GAAG,IAAI,EAAE,GAAG,IAAI,EAAC,CAAA;IAC7B,CAAC;IACD,IAAI,MAAM,GAAG,KAAK,CAAC,GAAG,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,OAAO,EAAE,OAAO,EAAE,CAAC,CAAA;IACtD,OAAO,CAAC,GAAG,CAAC,MAAM,CAAC,GAAG,CAAC;;;;;;"}